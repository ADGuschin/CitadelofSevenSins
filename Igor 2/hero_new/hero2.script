require "hero_new.test"
require "variables"

local alive

local flicker_mechanism = 0

local step_playing = false

local paused = false

local current_slide_moment = 0
local sliding = false
local slide_cooldown = 15
local slide_time = 30

local isFirstTimeRun = true
local invincibility = 0
local pushed = false

local invincible = false
local rolling_over = false
local pause = false
local roll_allowed = false
local lock_character = false
local impact_speed = vmath.vector3(1250, 750,0)

go.property("minSwipeDistance", 50)
go.property("minSwipeTime", 0.4)

local function enable_rolling_state(self)
	msg.post("#sliding_state", "disable")
	msg.post("#rolling_over_state", "enable")
	msg.post("#running_state", "disable")
end

local function enable_sliding_state(self)
	msg.post("#sliding_state", "enable")
	msg.post("#rolling_over_state", "disable")
	msg.post("#running_state", "disable")
end

local function enable_running_state(self)
	msg.post("#sliding_state", "disable")
	msg.post("#rolling_over_state", "disable")
	msg.post("#running_state", "enable")
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.position = go.get_position()
	self.velocity = vmath.vector3(0,0,0)
	enable_running_state(self)
	alive = true
	self.platform_contact_from_below = false
	self.platform_contact_from_below_last_frame = false
	counts_of_hero = counts_of_hero + 1
	print("Номер героя:"..counts_of_hero.." если написалось дважды но герой один значит что-то тут не так")
end

local function check_for_pause(self)
	msg.post("default:/hud#hud", "check_for_pause")
end

local function go_invincible(self)
	invincible = true
	print("going invincible")
	invincibility = 0
end

function final(self)
	msg.post(".", "release_input_focus")
end

local function flicker(self)
	if invincible then
		flicker_mechanism = flicker_mechanism + 1
		if flicker_mechanism % 2 == 0 then
			go.set("#sprite", "tint", vmath.vector4(1, 1, 1, 0))
		else
			go.set("#sprite", "tint", vmath.vector4(1, 1, 1, 1))
		end
	end
end

local function play_animation(self, anim)
	if self.anim ~= anim then
		msg.post("#sprite", "play_animation", {id = anim})
		self.anim = anim
	end
end

local function play_sound(self, sfx)
	if sfx ~= "step" then
		msg.post("sfx#sound_script", "stop_step")
		step_playing = false
	end
		msg.post("sfx#sound_script", sfx)
end

local function update_animation(self)
	if invincible then
		flicker(self)
	else 
		go.set("#sprite", "tint", vmath.vector4(1, 1, 1, 1))
	end
	if self.velocity.x < 0 then
		play_animation(self, hash("hero_impact"))
	elseif self.ground_contact then
		if sliding then
			play_animation(self, hash("player_slide"))
		elseif rolling_over then
			play_animation(self, hash("roll_over"))
		else
			if self.velocity.x > 0 then
				play_animation(self, hash("player_fast_right"))
			else
				play_animation(self, hash("player_right"))
			end
		end
	else
		if(self.velocity.y > 0) then
			play_animation(self, hash("player_jump"))
		else
			if self.velocity.y <= jump_break_speed then
				play_animation(self, hash("break_jump"))
			else
				play_animation(self, hash("player_fall"))
			end
		end
	end
end

local function slide_cooldown_tick(self)
	if slide_cooldown < slide_cooldown_max then
		slide_cooldown = slide_cooldown + 1
	end
end

local function check_inv(self)
	if invincibility < invincibility_max then
		invincibility = invincibility + 1
	else
		invincible = false
	end
end

local function check_slide(self)
	sliding = current_slide_moment > 0
end

local function break_slide(self)--на всякий пожарный,	 можно перенести в апдейт
	current_slide_moment = 0
	sliding = false
	enable_running_state(self)
end

local function break_roll(self)
	roll_allowed = false
	rolling_over = false
	lock_character = false
	enable_running_state(self)
end

function update(self, dt)
	check_for_pause(self)
	if not paused then
		local hero_position = go.get_position()

		check_slide(self)
		
		impact_speed.x = impact_speed.x + acceleration * dt
		if impact_speed.x > max_impact_speed then
			impact_speed.x = max_impact_speed
		elseif impact_speed.x < min_impact_speed then
			impact_speed.x = min_impact_speed
		end
		if not self.ground_contact then
			self.velocity.y = self.velocity.y + gravity
		else
			lock_character = false
			if not step_playing then
				--play_sound(self, "step")
				step_playing = true
			end
		end
		
		if self.velocity.y ~= 0  then
			if sliding then
				break_slide(self)
			end
			if rolling_over then
				break_roll(self)
			end
		end

		if rolling_over then
			lock_character = true
		end
		
		if self.velocity.x < 0 then
			self.velocity.x = self.velocity.x + 50			
		elseif pushed then
			pushed = false
			enable_running_state(self)
			go_invincible(self)
		end

		if not pushed then
			if hero_position.x < 360  then
					self.velocity.x = catch_up_speed
			else
				self.velocity.x = 0	
			end
		end

		check_inv(self)
		
		slide_cooldown_tick(self)
		
		if sliding then
			current_slide_moment = current_slide_moment + 1
			slide_cooldown = 0
			if current_slide_moment == slide_time then
				break_slide(self)
			end
		end
		
		go.set_position(go.get_position() + self.velocity * dt)

		update_animation(self)

		--update_sound(self)
		roll_allowed = false	
		self.correction = vmath.vector3()
		self.ground_contact = false
		self.platform_contact_from_below_last_frame = self.platform_contact_from_below
		self.platform_contact_from_below = false
	end
end


local function on_impact(self, impact_type)
	if impact_type == "hard" then
		play_sound(self, "impact")
		enable_running_state(self)
		play_animation(self, hash("hero_impact"))
		msg.post("controller#script", "reset_speed")
		self.velocity.y = impact_speed.y 
		self.velocity.x = -impact_speed.x
		pushed = true
		lock_character = true
		impact_speed.x = impact_speed.x * 0.66
	elseif impact_type == "soft" then
		roll_allowed = true
	end
end

local function handle_geometry_contact(self, normal, distance)
	local proj = vmath.dot(self.correction, normal)
	local comp = (distance - proj) * normal
	self.correction = self.correction + comp
	go.set_position(go.get_position() + comp)
	if normal.y > 0.7 then
		self.ground_contact = true
	end
	proj = vmath.dot(self.velocity, normal)
	if proj < 0 then
		self.velocity = self.velocity - proj * normal
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("jump") then
		if action.pressed then
			if current_slide_moment ~= 0 then
				break_slide(self)--на всякий пожарный
			end
			jump(self)
		elseif action.released then
			abort_jump(self)
		end
	elseif message_id == hash("reset") then
		msg.post("controller#script", "spawnhero")
		msg.post("#running_state", "enable")
	elseif message_id == hash("pause_state") then
		if message.value then
			paused = true
		else 
			paused = false
		end
	elseif message_id == hash("contact_point_response") then
		local pos = go.get_position()
		if (message.group == hash("danger") or pos.x < 10) and alive then
			alive = false
			play_animation(self, hash("player_die"))
			msg.post("#running_state", "disable")
			msg.post("#rolling_over_state", "disable")
			msg.post("#sliding_state", "disable")
			if true then
				--print("здох4")
				if autorestart_state then
					go.delete(true)
					msg.post("level:/controller#script", "reset")
					--print("здох2")
				else
					msg.post("default:/death_screen#death_screen", "death")
					msg.post("level:/controller#script", "death")  
					--print("здох3")
				end
			end
			isFirstTimeRun = false
		elseif message.group == hash("still_slide") then
			current_slide_moment = (2*slide_time) / 3
		elseif (message.group == hash("impact") and not pushed and not invincible) then
			on_impact(self, "hard")
		elseif message.group == hash("impact_soft") then
			on_impact(self, "soft")
		elseif message.group == hash("geometry") then
			handle_geometry_contact(self, message.normal, message.distance)
		elseif (message.group == hash("obstacle") and not (pushed or invincible)) then
			handle_geometry_contact(self, message.normal, message.distance)
		elseif message.group == hash("obstacle") and (invincible or pushed) then
			invincibility = 0.6*invincibility_max
			if message.normal.y > 0 then
				if not self.platform_contact_from_below_last_frame then
					handle_geometry_contact(self, message.normal, message.distance)
					self.platform_contact_from_below = false
				else
					self.platform_contact_from_below = true
				end
			else
				self.platform_contact_from_below = true
			end
		elseif message.group == hash("rolling_platform") then
			handle_geometry_contact(self, message.normal, message.distance)
		end
	end
end

local function jump(self, speed)
	play_sound(self, "jump")
	if self.ground_contact then
		self.velocity.y = speed
	end
end

local function abort_jump(self)
	if self.velocity.y > 0 then
		self.velocity.y = self.velocity.y * 0.4
	end
end

local function roll(self)
	if roll_allowed then
		play_sound(self, "roll")
		rolling_over = true
		enable_rolling_state(self)
	end
end

local function slide(self)
	if slide_cooldown == slide_cooldown_max then
		play_sound(self, "slide")
		enable_sliding_state(self)
		current_slide_moment = 1
	end
end

local function jump_break(self)
	play_sound(self, "break_jump")
	self.velocity.y = jump_break_speed
end

local beginX
local beginY
local endX
local endY

local startTime

local xDistance
local yDistance

go.property("minSwipeDistance", 20)
go.property("minSwipeTime", 0.2)

local bDoingTouch
local totalSwipeDistanceLeft
local totalSwipeDistanceRight
local totalSwipeDistanceUp
local totalSwipeDistanceDown

local touch

function checkSwipeDirection(self)
	print("hui")
	if bDoingTouch == true then
		xDistance =  math.abs(endX - beginX) -- math.abs will return the absolute, or non-negative value, of a given value.
		print("xd"..xDistance)
		yDistance =  math.abs(endY - beginY)
		print("yd"..yDistance)
		if xDistance > yDistance then
			if beginX > endX then
				totalSwipeDistanceLeft = beginX - endX
				if totalSwipeDistanceLeft > self.minSwipeDistance then
					print("Swiped Left")
					--action_id = hash("Swiped Left")
				end
			else
				totalSwipeDistanceRight = endX - beginX
				if totalSwipeDistanceRight > self.minSwipeDistance then
					print("Swiped Right")
					roll(self)
				end
			end
		else
			if beginY > endY then
				totalSwipeDistanceUp = beginY - endY
				if totalSwipeDistanceUp > self.minSwipeDistance and slide_cooldown == slide_cooldown_max then
					if self.ground_contact then 
						slide(self)
					else 
						jump_break(self)			
					end
				end
			else
				totalSwipeDistanceDown = endY - beginY
				if totalSwipeDistanceDown > self.minSwipeDistance then
					action_id = "slide"
					print("Swiped Up")
					jump(self, jump_takeoff_speed)
				end
			end
		end
	end
end

function swipe_on_input(self, action_id, action)
	if action_id == hash("touch") then
		--touch = action.click
		if action.pressed then
			bDoingTouch = true
			beginX = action.x
			beginY = action.y
			startTime = socket.gettime()
		end
		for i, tpoint in ipairs(action.touch) do 
			endX = action.x
			endY = action.y
			if socket.gettime() - startTime < self.minSwipeTime then
				checkSwipeDirection(self);
			end
		end 
		if action.released  then
			--[[endX = action.x
			endY = action.y
			if socket.gettime() - startTime < self.minSwipeTime then
				checkSwipeDirection(self);
			end--]]
			bDoingTouch = false
		end
	end
end

function on_input(self, action_id, action)
	if not lock_character then
		if action_id == hash("touch") then
			swipe_on_input(self, action_id, action)
		end
		--init_swipe(self)
		if action_id == hash("jump") --[[or action_id == hash("touch")]] then
			if action.pressed then
				if current_slide_moment ~= 0 then
					break_slide(self)--на всякий пожарный
				end
				jump(self, jump_takeoff_speed)
			elseif action.released then
				abort_jump(self)
			end
		end
		if action_id == hash("slide") and slide_cooldown == slide_cooldown_max then
			if self.ground_contact then
				slide(self)
			else 
				jump_break(self)
			end
		end
		if action_id == hash("roll_over") then
			if roll_allowed then
				roll(self)
			end
		end
	end
end