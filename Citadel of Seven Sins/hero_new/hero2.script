require "hero_new.test"
require "variables"

local alive

local prepare_slide = false

local flicker_mechanism = 0

local step_playing = false

local current_slide_moment = 0
local sliding = false
local slide_cooldown = 10
local slide_time = 30

local isFirstTimeRun = true
local invincibility = 0
local pushed = false

local invincible = false
local rolling_over = false
local pause = false
local roll_allowed = false
local lock_character = false
local impact_speed = vmath.vector3(1250, 750,0)

local swiped = false

go.property("minSwipeDistance", 50)
go.property("minSwipeTime", 0.4)

local function enable_rolling_state(self)
	msg.post("#sliding_state", "disable")
	msg.post("#rolling_over_state", "enable")
	msg.post("#running_state", "disable")
end

local function enable_sliding_state(self)
	msg.post("#sliding_state", "enable")
	msg.post("#rolling_over_state", "disable")
	msg.post("#running_state", "disable")
end

local function enable_running_state(self)
	msg.post("#sliding_state", "disable")
	msg.post("#rolling_over_state", "disable")
	msg.post("#running_state", "enable")
end

function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post(current_level..":/controller#script", "spawned") 
	self.position = go.get_position()
	self.velocity = vmath.vector3(0,0,0)
	enable_running_state(self)
	alive = true
	self.platform_contact_from_below = false
	self.platform_contact_from_below_last_frame = false
	counts_of_hero = counts_of_hero + 1
	print("Номер героя:"..counts_of_hero.." если написалось дважды но герой один значит что-то тут не так")
end

local function go_invincible(self)
	invincible = true
	--print("going invincible")
	invincibility = 0
end

function final(self)
	msg.post(".", "release_input_focus")
end

local function flicker(self)
	if invincible then
		flicker_mechanism = flicker_mechanism + 1
		if flicker_mechanism % 2 == 0 then
			go.set("#sprite", "tint", vmath.vector4(1, 1, 1, 0))
		else
			go.set("#sprite", "tint", vmath.vector4(1, 1, 1, 1))
		end
	end
end

local function play_animation(self, anim)
	if self.anim ~= anim then
		msg.post("#sprite", "play_animation", {id = anim})
		self.anim = anim
	end
end

local function play_sound(self, sfx)
	if sfx ~= "step" then
		msg.post("sfx#sound_script", "stop_step")
		step_playing = false
	end
		msg.post("sfx#sound_script", sfx, {id = "sfx"})
end

local function update_animation(self)
	if invincible then
		flicker(self)
	else 
		go.set("#sprite", "tint", vmath.vector4(1, 1, 1, 1))
	end
	if self.velocity.x < 0 then
		play_animation(self, hash("hero_impact"))
	elseif self.ground_contact then
		if sliding then
			play_animation(self, hash("player_slide"))
		elseif rolling_over then
			play_animation(self, hash("roll_over"))
		else
			if self.velocity.x > 0 then
				play_animation(self, hash("player_runfast_black"))
			else
				play_animation(self, hash("player_run_black"))
			end
		end
	else
		if(self.velocity.y > 0) then
			play_animation(self, hash("player_jump"))
		else
			if self.velocity.y <= jump_break_speed then
				play_animation(self, hash("break_jump"))
			else
				play_animation(self, hash("player_fall"))
			end
		end
	end
end

local function slide_cooldown_tick(self)
	if slide_cooldown < slide_cooldown_max then
		slide_cooldown = slide_cooldown + 1
	end
end

local function check_inv(self)
	if invincibility < invincibility_max then
		invincibility = invincibility + 1
	else
		invincible = false
	end
end

local function check_slide(self)
	sliding = current_slide_moment > 0
end

local function break_slide(self)--на всякий пожарный,	 можно перенести в апдейт
	current_slide_moment = 0
	sliding = false
	enable_running_state(self)
end

local function break_roll(self)
	roll_allowed = false
	rolling_over = false
	lock_character = false
	enable_running_state(self)
end


local function jump(self, speed)
	if self.ground_contact then
		play_sound(self, "jump")
		if speed > jump_takeoff_speed then
			speed = jump_takeoff_speed
		end
		self.velocity.y = speed
	end
	if pause_state then
		msg.post("default:/training#training", "jump")
	end
end

local function abort_jump(self)
	if self.velocity.y > 0 then
		self.velocity.y = self.velocity.y * 0.4
	end
end

local function roll(self)
	if roll_allowed and not sliding then
		break_slide(self)
		play_sound(self, "roll")
		rolling_over = true
		enable_rolling_state(self)
	end
	if pause_state then
		break_slide(self)
		msg.post("default:/training#training", "roll")
	end
end

local function slide(self)
	if slide_cooldown == slide_cooldown_max and not rolling_over then
		if not pause_state then
			play_sound(self, "slide")
		end
		enable_sliding_state(self)
		current_slide_moment = 1
	end
	if pause_state then
		msg.post("default:/training#training", "slide")
	end
end

local function jump_break(self)
	--if self.velocity.y > jump_break_speed then
	play_sound(self, "break_jump")
	self.velocity.y = jump_break_speed
	--end
end

local function jump_break_slide(self)
	--if self.velocity.y > jump_break_speed then
	play_sound(self, "break_jump")
	self.velocity.y = jump_break_speed
	prepare_slide = true
	--end
end

function update(self, dt)
	--invincible = true
	--lock_character = true
	if not pause_state then
		local hero_position = go.get_position()

		check_slide(self)

		if prepare_slide and self.ground_contact then
			slide(self)
			prepare_slide = false
		end
		
		impact_speed.x = impact_speed.x + acceleration * dt
		if impact_speed.x > max_impact_speed then
			impact_speed.x = max_impact_speed
		elseif impact_speed.x < min_impact_speed then
			impact_speed.x = min_impact_speed
		end
		if not self.ground_contact then
			self.velocity.y = self.velocity.y + gravity
		else
			lock_character = false
			if not step_playing then
				--play_sound(self, "step")
				step_playing = true
			end
		end
		
		if self.velocity.y ~= 0  then
			if sliding then
				break_slide(self)
			end
			if rolling_over then
				break_roll(self)
			end
		end

		if rolling_over then
			lock_character = true
		end
		
		if self.velocity.x < 0 then
			self.velocity.x = self.velocity.x + 50
		elseif pushed then
			pushed = false
			enable_running_state(self)
			go_invincible(self)
		end

		if not pushed then
			if hero_position.x < 360  then
					self.velocity.x = catch_up_speed
			else
				self.velocity.x = 0	
			end
		end

		check_inv(self)
		
		slide_cooldown_tick(self)
		
		if sliding then
			current_slide_moment = current_slide_moment + 1
			slide_cooldown = 0
			if current_slide_moment == slide_time then
				break_slide(self)
			end
		end
		
		go.set_position(go.get_position() + self.velocity * dt)

		update_animation(self)
		if training_state then
			lock_character = training_state
		end
		--update_sound(self)
		roll_allowed = false	
		self.correction = vmath.vector3()
		self.ground_contact = false
		self.platform_contact_from_below_last_frame = self.platform_contact_from_below
		self.platform_contact_from_below = false
	end
end


local function on_impact(self, impact_type)
	if impact_type == "hard" then
		play_sound(self, "impact")
		enable_running_state(self)
		play_animation(self, hash("hero_impact"))
		msg.post("controller#script", "reset_speed")
		self.velocity.y = impact_speed.y 
		self.velocity.x = -impact_speed.x
		pushed = true
		lock_character = true
		impact_speed.x = impact_speed.x * 0.66
	elseif impact_type == "soft" then
		roll_allowed = true
	end
end

local function handle_geometry_contact(self, normal, distance)
	local proj = vmath.dot(self.correction, normal)
	local comp = (distance - proj) * normal
	self.correction = self.correction + comp
	go.set_position(go.get_position() + comp)
	if normal.y > 0.7 then
		self.ground_contact = true
	end
	proj = vmath.dot(self.velocity, normal)
	if proj < 0 then
		self.velocity = self.velocity - proj * normal
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("continue") then
		msg.post("controller#script", "spawnhero", {continue = true})
		go.delete(true)
	elseif message_id == hash("contact_point_response") then
		local pos = go.get_position()
		if (message.group == hash("danger") or pos.x < 10) and alive and not invincible then
			alive = false
			play_animation(self, hash("player_die"))
			msg.post("#running_state", "disable")
			msg.post("#rolling_over_state", "disable")
			msg.post("#sliding_state", "disable")
			if autorestart_state then
				go.delete(true)
				msg.post(current_level..":/controller#script", "reset")
			else
				msg.post("default:/death_screen#death_screen", "death")
				msg.post(current_level..":/controller#script", "death")  
			end
		--[[elseif message.group == hash("danger") and invincible or pushed then
			invincibility = 0.6*invincibility_max]]
		elseif message.group == hash("still_slide") then
			current_slide_moment = (2*slide_time) / 3
		elseif (message.group == hash("impact") and not pushed and not invincible) then
			on_impact(self, "hard")
		elseif message.group == hash("impact_soft") then
			on_impact(self, "soft")
		elseif message.group == hash("geometry") then
			handle_geometry_contact(self, message.normal, message.distance)
		elseif (message.group == hash("obstacle") and not (pushed or invincible)) then
			handle_geometry_contact(self, message.normal, message.distance)
		elseif message.group == hash("obstacle") and (invincible or pushed) then
			invincibility = 0.6*invincibility_max
			--if message.normal.y > 0 or message.normal.y < 0 then
				--handle_geometry_contact(self, message.normal, message.distance)
			
			if message.normal.y > 0 then
				if not self.platform_contact_from_below_last_frame then
					handle_geometry_contact(self, message.normal, message.distance)
					self.platform_contact_from_below = false
				else
					self.platform_contact_from_below = true
				end
			else
				self.platform_contact_from_below = true
			end
		elseif message.group == hash("rolling_platform") then
			handle_geometry_contact(self, message.normal, message.distance)
		elseif message.group == hash("training") then
			lock_character = false
		elseif message.group == hash("coin") then
			play_sound(self, "coin")
			coins = coins + 1
			current_level_coins = current_level_coins + 1
		elseif message.group == hash("coin2") then
			play_sound(self, "coin")
			coins = coins + 2
			current_level_coins = current_level_coins + 2
		elseif message.group == hash("coin3") then
			play_sound(self, "coin")
			coins = coins + 3
			current_level_coins = current_level_coins + 3
		end
	end
end



local beginX
local beginY
local endX
local endY

local startTime

local xDistance
local yDistance

go.property("minSwipeDistance", 20)
go.property("minSwipeTime", 0.2)

local bDoingTouch
local totalSwipeDistanceLeft
local totalSwipeDistanceRight
local totalSwipeDistanceUp
local totalSwipeDistanceDown
local swipe
local touch

function checkSwipeDirection(self)
	if bDoingTouch == true then
		xDistance =  math.abs(endX - beginX) -- math.abs will return the absolute, or non-negative value, of a given value.
		print("xd"..xDistance)
		yDistance =  math.abs(endY - beginY)
		print("yd"..yDistance)
		if xDistance > yDistance then
			if beginX > endX then
				totalSwipeDistanceLeft = beginX - endX
				if totalSwipeDistanceLeft > self.minSwipeDistance then
					print("Swiped Left")
					bDoingTouch = false
					--action_id = hash("Swiped Left")
				end
			else
				totalSwipeDistanceRight = endX - beginX
				if totalSwipeDistanceRight > self.minSwipeDistance then
					print("Swiped Right")
					roll(self)
				end
			end
		else
			if beginY > endY then
				totalSwipeDistanceUp = beginY - endY
				if totalSwipeDistanceUp > self.minSwipeDistance and slide_cooldown == slide_cooldown_max then
					bDoingTouch = false
					if self.ground_contact then 
						slide(self)
					else 
						jump_break_slide(self)
					end
				end
			else
				totalSwipeDistanceDown = endY - beginY
				if totalSwipeDistanceDown > self.minSwipeDistance then
					bDoingTouch = false
					if options_swipe then
						print("Swiped Up")
						jump(self, jump_takeoff_speed)
					end
				end
			end
		end
	end
end

function swipe_on_input(self, action_id, action)
	if action_id == hash("click") then
		--print("click")
		if action.pressed then
			startTime = socket.gettime()
			beginX = action.x
			beginY = action.y
			bDoingTouch = true
		end
		if socket.gettime() - startTime > 0.001 then
			touch = (math.abs(beginX - action.x) < 1) and (math.abs(beginY - action.y) < 1)
			swipe = not touch
		end

		if touch and options_touch then
			touch = false
			if self.ground_contact and bDoingTouch then
				jump(self, jump_takeoff_speed)
				bDoingTouch = false
			elseif bDoingTouch then
				jump_break(self)
				bDoingTouch = false
			end
		elseif swipe then
			swipe = false
			if socket.gettime() - startTime < self.minSwipeTime then
				endX = action.x
				endY = action.y
				checkSwipeDirection(self)
			end
		end
		if action.released and options_touch then
			if not self.ground_contact then
				abort_jump(self)
			end
			bDoingTouch = false
		end
		--[[for i, tpoint in ipairs(touch) do 
			
			
		end ]]
		--[[if action.released  then
			if socket.gettime() - startTime < 10 then
				print(self.minSwipeTime)
			end
			endX = action.x
			endY = action.y
			if socket.gettime() - startTime < self.minSwipeTime then
				checkSwipeDirection(self);
			end
			bDoingTouch = false
		end]]
	end
end

function on_input(self, action_id, action)
	if not lock_character then
		if action_id == hash("click") then
			swipe_on_input(self, action_id, action)
		end
		--init_swipe(self)
		if action_id == hash("jump") --[[or action_id == hash("touch")]] then
			if action.pressed then
				if current_slide_moment ~= 0 then
					break_slide(self)--на всякий пожарный
				end
				jump(self, jump_takeoff_speed)
			elseif action.released then
				abort_jump(self)
			end
		end
		if action_id == hash("back_pause") then
			msg.post("default:/hud#hud", "pause")
		end
		if action_id == hash("slide") and slide_cooldown == slide_cooldown_max then
			if self.ground_contact then
				slide(self)
			else 
				jump_break(self)
			end
		end
		if action_id == hash("roll_over") then
			if roll_allowed then
				roll(self)
			end
		end
	end
end

function final(self)
	current_level_coins = 0
end