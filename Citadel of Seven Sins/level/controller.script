require "level.obstacle_table"
require "level.utils"
require "variables"
-- controller.script
local grid = 600
local grido = 2100
local platform_height = 48
local default_speed = 460

local max_speed = 1500
local obstacle_var = 0
local reset_timer = 0
local reset_timer_max = 5
local current_hero

local previous_obstacle
table_backgrounds_objects = {"#garage","#barrel","#tent_1","#tent_2","#tent_3","#tent_4"}


function table_length(self, table)
    local count = 0
    for x in pairs(table) do count = count + 1 end
    return count
end

function init(self)
    --index_of_current_level = 1 -- пока что захардкодил для теста
    --current_level = list_of_levels[index_of_current_level]
    print(current_level)
    self.speed = default_speed
    update_speed(self)
    self.gridw = 0
    self.gridbackground = 0
    --self.heroes = {}
    if training_state then
        previous_obstacle = "training"
    else
        previous_obstacle = "init"--obstacle_table["init"][math.random(table_length(self, obstacle_table["init"]))]
    end
    msg.post("#", "spawnhero")
    --print(msg.url())
end

function spawn_pickups(self, params)
    for i = 1, params.count do
        local spawn_position = vmath.vector3(params.pickup_positions[i].x + 1600, params.pickup_positions[i].y, 1)
        if(previous_obstacle == "#obstacle_small") and math.random() > 0.65 then
            spawn_position.y = spawn_position.y + 200
        elseif(previous_obstacle == "#obstacle_top_kran") and math.random() > 0.65 then
            spawn_position.y = spawn_position.y - 230
        end
        if score > 100 and score < 250 then 
            local random = score/math.random(100, 250)
            if random >= 1 then
                factory.create("#coin2", spawn_position , nil, {}, 4)
            else
                factory.create("#coin", spawn_position , nil, {}, 4)
            end
        elseif score > 250 then
            local random = score/math.random(300, 500)
            if random >= 1 then
                factory.create("#coin3", spawn_position , nil, {}, 4)
            else
                factory.create("#coin2", spawn_position , nil, {}, 4)
            end
        else
            factory.create("#coin", spawn_position , nil, {}, 4)
        end
    end
end

function check_for_reset(self)
    if reset_timer < reset_timer_max then
        reset_timer = reset_timer + 1
    else 
        reset = false
    end
end


function calculate_score(self)
    if not pause_state then
        score = score + self.speed / 10000
        if current_score_multiplier.next ~= "none" then 
            multiplier_bar = multiplier_bar + self.speed / 10000
            if multiplier_bar >= bar_maxs[current_score_multiplier.next] then
                multiplier_bar = 0
                current_score_multiplier = score_multiplier[current_score_multiplier.next]
                msg.post("/score#score", "change_multiplier")
            end
        end
        msg.post("/score#score", "score", {value = math.ceil(score)})
        msg.post("/score#score", "coins", {value = coins})
    end
end

function update(self, dt)
    self.gridw = self.gridw + self.speed * dt
    self.gridbackground = self.gridbackground + ((self.speed * 200) / 360) * dt
    if self.gridbackground >= grido then
        self.gridbackground = 0
        local indx = math.random(1,6)
        local obj = table_backgrounds_objects[indx]
        pprint(indx)
        pprint(obj)
        if indx == 1 then
            collectionfactory.create(obj, vmath.vector3(1600, 195, -0.55), nil, {}, 4)
        else
            collectionfactory.create(obj, vmath.vector3(1600, 100, -0.45), nil, {}, 4)
        end
    end
    if self.speed < max_speed then 
        self.speed = self.speed + acceleration * dt
    end
    --update_speed(self)
    check_for_reset(self)
    if self.gridw >= grid then
        self.gridw = 0
        local h = platform_height
        local allowed_obstacles = obstacle_table[previous_obstacle]
        local random = math.random(table_length(self, allowed_obstacles))
        grid = grid_table[allowed_obstacles[random]]
        --pprint(grid_table[previous_obstacle])
        --pprint(previous_obstacle)
        previous_obstacle = allowed_obstacles[random] 
        local p = collectionfactory.create(previous_obstacle, vmath.vector3(1600, h, 0), nil, {}, 4)
        spawn_pickups(self, pickups_param_table[previous_obstacle])
    end
    calculate_score(self)

end

function on_message(self, message_id, message, sender)
    if message_id == hash("reset_multiplier") then
        msg.post("/score#score", "change_multiplier")
    elseif message_id == hash("spawnhero") then
        local p = factory.create("#herofactory",vmath.vector3(300, 142, 0), nil,{},4)
        --table.insert(self.heroes, p)
        if message.continue == nil then
            score = 0 
        end
    elseif message_id == hash("spawned") then
        current_hero = sender
    elseif message_id == hash("continue") then
        msg.post(current_hero, "continue")
    elseif message_id == hash("reset") then 
        save_gamedata()
        training_state = next_try_is_training
        next_try_is_training = false
        if training_state then
            previous_obstacle = "training"
        else
            previous_obstacle = "init"
        end
        -- Tell the hero to reset.
        reset = true
        reset_timer = 0
        self.speed = default_speed
        msg.post("#", "spawnhero")
        msg.post("background3/controller#background3", "reset")
        msg.post("bacground3_loop/controller#background3_loop", "reset")
    elseif message_id == hash("reset_speed") then
        self.speed = self.speed * 0.77
        if self.speed < default_speed then
            self.speed = default_speed
        elseif self.speed > max_speed then
            self.speed = max_speed
        end
    elseif message_id == hash("speed_request") then
        msg.post(sender, "set_speed", { speed = self.speed })
    elseif message_id == hash("death") then
        training_state = next_try_is_training
        next_try_is_training = false
        if training_state then
            previous_obstacle = "training"
        else
            previous_obstacle = "init"
        end
        msg.post("default:/death_screen#death_screen", "score", {value = math.ceil(score)})
    end
end

function update_speed(self)
    msg.post("background1/controller#script", "set_speed", { speed = self.speed })
    msg.post("background2/controller#script", "set_speed", { speed = self.speed })
    msg.post("background3/controller#background3", "set_speed", { speed = self.speed })
end